# 浏览器的缓存机制
## 参考资料
> [深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)
## 缓存位置
1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

### Service Worker
> Service Worker 是运行在浏览器背后的独立线程，可以用来实现缓存功能。
> 因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

> Service Worker实现缓存功能一般分为三个步骤:
1. 注册 Service Worker
2. 监听到 install 事件以后就可以缓存需要的文件
3. 下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

> 如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

### Memory Cache
> Memory Cache就是内存中的缓存，读取内存中的数据比磁盘快，内存缓存读取很高效，但持续性会很短，会随着进程的释放而释放。
> 内存缓存中有一快重要的缓存资源是preloader指令，（例如<link rel="prefetch">）下载的资源，这是页面优化的常用手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。
> 内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

### Disk Cache
> Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

> 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。

### Push Cache
> 推送缓存是HTTP/2中的内容，当上述三种缓存都没有命中的时候，它会被使用。它只在会话中存在，一旦会话结束就会被释放，并且缓存时间也很短暂，在chrome浏览器中只存在五分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

## 强缓存
> 不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。

### Expires
> 缓存过期时间，用来指定资源到期的时间，是服务器端的具体时间点。

> 是HTTP/1的产物，受限于本地时间，如果修改了本地时间，会造成缓存失效。

### Cache-Control

## 协商缓存
> 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程.

> 协商缓存生效，返回304和Not Modified;协商缓存失效，返回200和请求结果.

### ETag
> Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。
> 浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。
> 如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

### Last-Modified和If-Modified-Since
> 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header。

> 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源

> 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

## 缓存机制
> 强制缓存优先于协商缓存，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200.重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。

## 实际应用
### 频繁变动的资源
> Cache-Control: no-cache
> 对于频繁变动的资源，使用Cache-Control: no-cache使浏览器每次都请求服务器，然后配合ETag和Last-Modified验证资源是否有效。

### 不常变化的资源
> Cache-Control: max-age=31536000
> 处理这类资源时，给他们的 Cache-Control 配置一个很大的 max-age=31536000，这样浏览器之后请求相同的URL会命中强制缓存。
> 解决更新的问题，就需要在文件名后面添加hash，版本号等字符，从而达到更改引用URL的目的。
> 在线提供的类库均采用这个模式。

## 用户行为对浏览器缓存的影响
> 打开网页输入URL: 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。

> 普通刷新: 优先使用memory cache, 如果没有，查找是否有disk cache。

> 强制刷新: 不实用缓存，发送的请求头部均带有Cache-control: no-cache，服务器直接返回200和最新内容。