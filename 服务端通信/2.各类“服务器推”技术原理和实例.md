# 各类“服务器推”技术原理和实例
## 参考资料
> [各类“服务器推”技术原理与实例](https://juejin.im/post/5b135b78f265da6e420eab7d
## 概括
在大多数场景下，客户端的主动式行为已经可以满足需求了，但是在一些场景下，需要服务器主动向客户端推送数据。

“服务器推”技术由来已久，从最初的简单轮询，到后来基于长轮询的COMET，到HTML5规范的SSE，以及实现全双工的WebSocket协议，“服务器推”的技术不断发展

## 1.简易轮询
简易轮询本质上就是在前端创建一个定时器，每隔一定的时间去查询后端服务，如果有数据则进行相应的处理。

这种相当于定时轮询的方式在获取数据上存在显而易见的延迟，要想降低延迟，只能缩短轮询间隔；而另一方面，每次轮询都会进行一次完整的HTTP请求，如果没有数据更新，相当于是一次“浪费”的请求，对服务端资源也是一种浪费。

## 2.COMET
lex Russell（Dojo Toolkit 的项目 Lead）称这种基于HTTP长连接、无须在浏览器端安装插件的“服务器推”技术为“Comet”。

### 2.1 基于HTTP的长轮询

客户端发起请求后，服务端会保持住该链接，直到后端有数据更新后，才会将新数据返回给客户端；客户端在收到响应结果后再次发送请求，如此循环往复。

### 2.2 基于iframe的长连接流(stream)模式

我们可以在页面中嵌入一个iframe并设置src，服务端就可以通过长链接源源不断的向客户端输出内容。

在iframe的父页面里定义一个处理函数, 每次有新数据需要推送时，服务端在该连接响应中写入<script>parent.process(${your_data})</script>。
那么iframe中的这段代码就会调用父页面中定义的process()函数。（类似JSONP）

不过使用iframe有个小瑕疵，这个iframe相当于一直处于加载中状态，因此浏览器标签上会一直有个loadding。

### 然而，COMET技术并不是HTML5标准的一部分，从兼容标准的角度出发的话，并不推荐使用。

## 3.SSE(Server-Sent Events)
SSE是HTML5标准中的一部分

HTTP响应内容有一种特殊的content-type —— text/event-stream，该响应头标识了响应内容为事件流，客户端不会关闭连接，而是等待服务端不断得发送响应结果。

SSE规范比较简单，主要分为两部分: 浏览器中的EventSource对象，以及服务器端与浏览器端之间的通信协议。

在浏览器端通过EventSource构建一个对象，SSE的响应内容可以看成是一个事件流，监听这个事件来获得服务端的通知。

SSE中的每个事件由类型和数据两部分组成。

类型为data，表示该行是传回的数据，类型为event, 表示该行声明的是事件类型。浏览器在收到数据时，会对应到监听的相应事件。

类型为 retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间。

## 4.WebSocket
WebSocket与http协议一样都是基于TCP的。WebSocket其实不仅仅限于“服务器推”了，它是一个全双工的协议，适用于需要进行复杂双向数据通讯的场景。
因此也有着更复杂的规范。


