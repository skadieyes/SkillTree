# webassembly汇编语言
1. S-表达式
> (module)

2. 数据类型
> i32,i64: 整型数
> f32,f64: 浮点数
> 无符号: _u, 有符号: _s

3. 函数定义
> (func<函数签名><局部变量表><函数体>)
> 函数签名表明了函数的参数和返回值，它由一系列的param结点和result返回值构成。
> 局部变量: 由一系列local结点组成
> 函数体: 由一系列汇编指令构成
> 函数别名: webassembly可以在func后增加一个以$开头的名字，例如(func $add ...)
> 注意，由于webassembly中函数不可嵌套，所以对于函数所处的模块来说，所有的函数都是全局函数。

4. 变量
> 函数体如何读写参数和局部变量呢: get_local set_local, get_local通过索引获取参数/局部变量
> 变量别名: (param $p0 i32) get_local $p0;
> 全局变量: (global <别名><类型><初值>)  <类型>中mut表示是否是可变全局变量
> 在webassembly中，全局对象可以在module的任意位置声明和使用，无需遵循先声明后使用的原则。
> 全局变量，局部变量都不占用内存地址空间，三者各自独立。

5. 栈式虚拟机
> 栈是一种先入后出的数据结构
> webassembly不仅是一门编程语言，也是一套虚拟机结构规范
> 每个未返回的函数占用栈上一段独立的连续区域，这段区域被称为栈帧
> webassembly会执行严格的检查保证栈帧匹配，如果函数声明了i32的返回值，那么函数执行完毕后，栈内必须包含且仅包含一个i32类型的值.

6. 函数调用
> 直接调用: call n
> 间接调用: call_indirect(type n) 间接调用允许我们使用变量来调用函数
> 递归调用: 允许调用自身，谨慎使用，避免递归过深导致内存溢出

7. 内存读写
> 内存初始化: (memory initial_size)
> 为内存赋值: (data (offset i32.const 0) "hello")
> 读取内存: load指令 将内存地址先压入栈中，然后调用指定类型的load指令
> 写入内存: store指令 先将内存地址入栈，然后将数据入栈，调用store
> 内存扩容: 获取内存容量 memory.size 扩容 memory.grow

8. 控制流
> nop 和 unreachable : 负责中断
> block指令块: block和end之间包围的指令块构成一个指令块，指令块拥有自己独立的栈帧，指令块可以有返回值，当指令
> if指令块
> loop指令块: 如果内部不含跳转指令，行为与Block一致
> 指令块label： 指令块被隐式的赋予了label索引，label索引由指令块的嵌套深度决定，位于最内层的指令块索引是0，每往外一层索引+1，label也可以自定义命名，label的用处是作为跳转指令的目标。
> br: br的作用是跳出指令块，对于block/loop来说，br会跳转到block的end，loop的开始处。
> br_if: br_if L 作用与br相似，区别是br_if执行的时候，会从栈上弹出一个i32类型的值，如果该值不等于0，则继续执行br L的操作。
> return: 直接跳至函数结尾
> br_table ???

9. 导入和导出
> 导入: 使用WebAssembly.Module.imports()可以获取模块的导入对象信息
> 通过导入函数，WebAssembly可以调用外部JavaScript环境中的方法，执行读写DOM等操作。

9. start函数以及指令折叠
> 在WebAssembly中调用start()函数，可以让start段引用的函数自动执行。需要注意，start段引用的启动函数不能有返回值，否则无法通过静态检测。
> 用S表达式折叠指令: 可以把每条一行的指令折叠到括号里，折叠后执行原则是从内到外，从左到右。结构化指令折叠后不需要再写end，if指令折叠需要写then和else。